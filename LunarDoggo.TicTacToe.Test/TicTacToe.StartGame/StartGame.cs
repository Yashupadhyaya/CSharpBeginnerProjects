// ********RoostGPT********
/*
Test generated by RoostGPT for test chshapunit-testing using AI Type  and AI Model 

ROOST_METHOD_HASH=StartGame_ea5458875f
ROOST_METHOD_SIG_HASH=StartGame_941d5801f0

   ########## Test-Scenarios ##########  

Scenario 1: Test to validate successful game start

  Details:
    TestName: TestSuccessfulGameStart
    Description: This test is meant to check if the game successfully starts. The game starts when the current player is set to the first player and the game board is reset.

  Execution:
    Arrange: Mock the game board and the players.
    Act: Invoke the StartGame method.
    Assert: Check if the current player is the first player and the game board is reset.

  Validation:
    The assertion aims to verify that the game starts successfully by setting the current player to the first player and resetting the game board. This is important to ensure the game setup is correct before the game begins.


Scenario 2: Test to validate the TilesReset event invocation

  Details:
    TestName: TestTilesResetEventInvocation
    Description: This test is meant to check if the TilesReset event is invoked when the game starts.

  Execution:
    Arrange: Mock the game board and the players and subscribe to the TilesReset event.
    Act: Invoke the StartGame method.
    Assert: Check if the TilesReset event was invoked.

  Validation:
    The assertion aims to verify that the TilesReset event is invoked when the game starts. This ensures that the game board UI is updated correctly when the game begins.


Scenario 3: Test to validate game start when the game is already in progress

  Details:
    TestName: TestGameStartInProgress
    Description: This test is meant to check if the game can be started when it's already in progress.

  Execution:
    Arrange: Mock the game board and the players and start the game.
    Act: Invoke the StartGame method again.
    Assert: Check if the current player is reset to the first player and the game board is reset.

  Validation:
    The assertion aims to verify that the game can be reset and started again even if it's already in progress. This is important to allow players to restart the game at any time. 


Scenario 4: Test to validate game start error handling

  Details:
    TestName: TestGameStartErrorHandling
    Description: This test is meant to check if any errors during game start are handled properly.

  Execution:
    Arrange: Mock the game board and the players and simulate an error condition (like null game board).
    Act: Invoke the StartGame method.
    Assert: Check if the appropriate error is thrown.

  Validation:
    The assertion aims to verify that any errors during game start are handled properly. This is important to ensure the game does not crash due to unexpected conditions. 


Scenario 5: Test to validate game start with uninitialized players

  Details:
    TestName: TestGameStartWithUninitializedPlayers
    Description: This test is meant to check if the game can be started with uninitialized players.

  Execution:
    Arrange: Mock the game board and do not initialize the players.
    Act: Invoke the StartGame method.
    Assert: Check if the appropriate error is thrown.

  Validation:
    The assertion aims to verify that the game cannot be started without initializing the players. This is important to ensure that the game setup is correct before the game begins.


*/

// ********RoostGPT********
using System;
using System.Linq;
using NUnit.Framework;
using Moq;
using TicTacToe;

namespace TicTacToe.Test
{
    [TestFixture]
    public class StartGameTest
    {
        private GameState _gameState;

        [SetUp]
        public void Setup()
        {
            var buttonTileMappings = new ButtonTileMapping[]
            {
                new ButtonTileMapping(new Button(), 0, 0),
                new ButtonTileMapping(new Button(), 1, 0),
                new ButtonTileMapping(new Button(), 2, 0),
                new ButtonTileMapping(new Button(), 0, 1),
                new ButtonTileMapping(new Button(), 1, 1),
                new ButtonTileMapping(new Button(), 2, 1),
                new ButtonTileMapping(new Button(), 0, 2),
                new ButtonTileMapping(new Button(), 1, 2),
                new ButtonTileMapping(new Button(), 2, 2),
            };

            _gameState = new GameState(buttonTileMappings);
        }

        [Test]
        public void TestSuccessfulGameStart()
        {
            _gameState.StartGame();

            Assert.AreEqual(1, _gameState.CurrentPlayer.Id);
            Assert.IsTrue(_gameState.GameBoard.Tiles.All(tile => tile == 0));
        }

        [Test]
        public void TestTilesResetEventInvocation()
        {
            bool isEventInvoked = false;

            _gameState.TilesReset += (sender, e) => isEventInvoked = true;

            _gameState.StartGame();

            Assert.IsTrue(isEventInvoked);
        }

        [Test]
        public void TestGameStartInProgress()
        {
            _gameState.StartGame(); // Start the game
            _gameState.CurrentPlayer = _gameState.SecondPlayer; // Change the current player

            _gameState.StartGame(); // Start the game again

            Assert.AreEqual(1, _gameState.CurrentPlayer.Id);
            Assert.IsTrue(_gameState.GameBoard.Tiles.All(tile => tile == 0));
        }

        [Test]
        public void TestGameStartErrorHandling()
        {
            _gameState.GameBoard = null;

            Assert.Throws<NullReferenceException>(() => _gameState.StartGame());
        }

        [Test]
        public void TestGameStartWithUninitializedPlayers()
        {
            _gameState.FirstPlayer = null;
            _gameState.SecondPlayer = null;

            Assert.Throws<NullReferenceException>(() => _gameState.StartGame());
        }
    }
}
